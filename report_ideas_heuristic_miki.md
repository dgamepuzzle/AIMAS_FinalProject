## Background

We have developed a centralized planner that always keeps the agents busy, while minimizing the amount of moves required to complete their tasks. The planner employs a novel allocation mechanism based on a minimum-cost matching algorithm called the "Hungarian algorithm". The procedure assigns boxes to goals and agents to boxes in a way that the total move/push distance is minimized. This way, each of the agents can focus on one box and a corresponding goal at a time, significantly reducing the breadth of the state space search tree.

## Related work

The Hungarian algorithm [1] is a costly O($n^3$) operation (where n represents the amount of boxes), and as a result, some papers on Sokoban solvers disregard it in favour of faster, but less precise approximation algorithms [2]. The ones that actually apply this minimum-cost matching algorithm either do not go into the implementation details, or apply it only in single-agent Sokoban levels [3][4].

In contrast to these solvers, We have come up with an approach that generalizes the use of Hungarian algorithm, so it can work with both single- and multi-agent levels.

## Methods

Our client directs the agents by using two mechanisms - the heuristic function and the collision avoidance during state generation.

The client maintains an array of tasks corresponding to agent-box-goal allocations, and calculates the heuristic values accordingly. Tasks are generated by the Hungarian algorithm, that calculates minimum-cost matching between level elements (goals and boxes, boxes and agents). As the input of the algorithm, we use "real" map distances that take walls into account. These metrics can be pre-calculated by running BFS from each level location, if we relax the planning problem by not considering the boxes and agents present in the level.

Allocations take place at the program's initialization, and in each state whenever a box is pushed into a goal. An allocation step consists of the following procedures:

- Let $G_U$ denote the set of non-fulfilled goals.
- Let $B_U$ denote the set of boxes that have not been pushed into their goals.
- Let $A$ denote the set of all agents on the map.

- For each goal/box letter L:

  - Calculate distances between all possible goal-box pairs of $G_{UL}$ and $B_{UL}$ - resulting in a distance (cost) matrix.
  - Run Hungarian algorithm with the above cost matrix as an input, to match a box to each of the unfulfilled goals. Disregard any extra boxes.

- Let $B_A$ denote the set of boxes that have been assigned to a goal in the previous step.

- For each agent/box color C:
  - Calculate distances between all possible agent-box pairs of $A_{UC}$ and $B_{AC}$.
  - Run Hungarian algorithm with the above cost matrix as an input, to match a box to each of the agents. Disregard any extra boxes or agents.

This way, agents are always occupied with tasks, and get a new task (a particular box to be pushed into a particular goal) everytime they complete their current task, or run out of goals to fulfill.

Now as we have covered the allocation algorithm, it makes sense to discuss the heuristic function itself. The heuristic function includes five terms that are weighted differently.

- $h_{goal-box}$ - Sum of distances between allocated goals and boxes. It motivates agents to move boxes towards their corresponding goals.
- $h_{agent-box}$ - Sum of distances between allocated agents and boxes. It incentivizes agents to move towards their corresponding boxes.
- $h_{fulfilled-goal-box}$ - Sum of distances between fulfilled goals and their corresponding boxes. It punishes agents for moving boxes that are already in their goals.
- $h_{unassigned-agent}$ - Distance traveled by unassigned agents compared to the previous state. Punishes the unnecessary movement (and state generation) of jobless agents.
- $h_{unassigned-box}$ - A punishment added for each unassigned box that does not fulfill a goal. Its role is to make the heuristic function consistent.

The final heuristic function takes the form of

$h(state) = w_1 * h_{goal-box} + w_2 * h_{agent-box} + w_3 * h_{fulfilled-goal-box} + w_4 * h_{unassigned-agent} + w_5 * h_{unassigned-box}$

in which $w_1...w_5$ are weights corresponding to the "importance" of each heuristic term. For instance, $h_{unassigned-box}$ has to outweigh all the other heuristic terms to keep the heuristic consistent.




# Literature (to be extended)
[1][Kuhn, H. W, P. 2015. The Hungarian method for the assignment problem in Naval Research Logistics 52(1):7-21](https://findit.dtu.dk/en/catalog/2520163102)

[2][Froleyks, N. 2016. Using an Algorithm Portfolio to Solve Sokoban](https://baldur.iti.kit.edu/theses/SokobanPortfolio.pdf)

[3][Junghanns, A. 2009. Pushing the Limits: New Developments in Single-Agent Search](https://findit.dtu.dk/en/catalog/2261200197)

[4][Virkkala, T. 2011. Solving Sokoban, University of Helsinki](http://sokoban.dk/wp-content/uploads/2016/02/Timo-Virkkala-Solving-Sokoban-Masters-Thesis.pdf)




